.text
0x24 .text
0x9F51 .bss
0x1A1 start
0x1A1 _start
0x39B2 main
0x9F51 __argc
0xA3D5 __argv
0x9FD5 __path
0x24 
0x2E1 md5_transform
0x12A0 md5_init
0x130C md5_update
0x13CF md5_final
0x573C memset
0x24 
0x1801 sha1_transform
0x1C68 sha1_init
0x1D21 sha1_update
0x1DE4 sha1_final
0x24 
0x2222 draw_error_box
0x2453 get_mouse_pos
0x5710 memmove
0x238A begin_draw
0x23BC sys_create_window
0x9501 L.8
0x2423 draw_text_sys
0x23A3 end_draw
0x22B3 error_box
0x24CA set_event_mask
0x248D get_os_event
0x24AA get_os_button
0x59B8 exit
0x24 
0x9509 k
0x24EC sha256_transform
0x2933 sha256_init
0x29DF sha256_update
0x2AA2 sha256_final
0x24 
0xA7D5 sys_color_table
0x9609 hex
0x9620 hash_str_md5
0x9661 hash_str_sha1
0x96A2 hash_str_sha256
0xA7FD edit_box_buff
0xA83E filename
0xAC3E title
0x96E5 str_pos
0x96E9 md5_flag
0x96ED sha1_flag
0x96F1 sha256_flag
0x96F5 edit_box_text_color
0x2F8B edit_box
0x57AC strchr
0x303A safe_malloc
0x46F4 wtmalloc
0x96F9 L.12
0x3089 md5_hash
0x4240 fread
0x4B57 wtfree
0x310B sha1_hash
0x318D sha256_hash
0x320F check_sum
0x9712 L.13
0x3F70 fopen
0x3EE8 fclose
0x32E6 sprint_hash
0x9715 L.14
0x46C4 sprintf
0x5754 strcat
0x336B redraw_window
0x3DD2 get_mouse_pos
0x971A L.15
0x3CAE begin_draw
0x3CE0 sys_create_window
0x3D69 draw_bar
0x3DA2 draw_text_sys
0x3D47 define_button
0x972D L.16
0x9732 L.17
0x9738 L.18
0x9740 L.19
0x9745 L.20
0x974A L.21
0x974F L.22
0x9757 L.23
0x3CC7 end_draw
0x3739 copy_to_clipboard
0x58FC strlen
0x586C strcpy
0x3E7B kol_clip_set
0x3799 print_pending_calc
0x975D L.24
0x37BB calc_and_cmp
0x57F8 strcmp
0x3821 hash_compare
0x9795 L.25
0x97A7 L.26
0x97AA L.27
0x3EA5 get_system_colors
0x3EC6 set_event_mask
0x3E0C get_os_event
0x3E29 get_key
0x3E5B get_os_button
0x97BD errno
0x58A8 strdup
0x556C _ksys_get_filesize
0x56F4 memcpy
0x55C4 _ksys_readfile
0x77FD format_print
0x97C9 __freebase
0x97CD __freetop
0x97D1 __firstfree
0xB049 wtalloc_stat
0x97D5 L.3
0x97FE L.4
0x9811 L.5
0x9813 L.6
0x9848 L.7
0x987A L.8
0x988D L.9
0x988F L.10
0x98BF L.11
0x98D2 L.12
0x98D4 L.13
0x9908 L.14
0x9938 L.15
0x997D L.16
0x9986 L.17
0x9988 L.18
0x99BC L.19
0x99E0 L.20
0x9A05 L.21
0x9A2C L.22
0x9A35 L.23
0x9A5A L.24
0x9A81 L.25
0x97C1 c_used
0x97C5 c_free
0x553C debug_out_str
0x5938 __assert_func
0x85E8 sysmalloc
0x4FAA wtrealloc
0x516A wtcalloc
0x51BA wtmalloc_freelist_check
0x52DE wtmalloc_freelist_print
0x5367 wtmalloc_poiner_check
0x53C8 wtdump_alloc_stats
0x5520 .text
0x5520 _ksys_debug_out
0x556C .text
0x5614 _ksys_rewritefile
0x5660 _ksys_appendtofile
0x56F4 .text
0x573C .text
0x9AA9 L.2
0x9AD1 L.3
0x85B8 snprintf
0x597E __trace_func
0xB06D __console_initdll_status
0xB075 con_exit
0x8690 _ksys_exit
0x9AF5 L.0
0x9B05 L.1
0x9B75 L.2
0x9B7B L.3
0x9B83 L.4
0x9B8C L.5
0x9B9D L.6
0x9BAE L.7
0x9BB9 L.8
0x9BC2 L.9
0x9BD0 L.10
0x9BDE L.11
0x9BE8 L.12
0x9BF2 L.13
0x9BFD L.14
0x9C06 L.15
0x9C10 L.16
0x9C24 L.17
0x9C3A L.18
0x9C50 L.19
0x9C58 L.20
0x9C6B L.21
0x9C7E L.22
0x9C8C L.23
0x9AF1 con_caption
0xB069 con_dll_ver
0x9B01 con_dllname
0xB071 con_init
0xB079 con_set_title
0xB07D con_write_asciiz
0xB081 con_write_string
0xB085 con_printf
0xB089 con_get_flags
0xB08D con_set_flags
0xB091 con_get_font_height
0xB095 con_get_cursor_height
0xB099 con_set_cursor_height
0xB09D con_getch
0xB0A1 con_getch2
0xB0A5 con_kbhit
0xB0A9 con_gets
0xB0AD con_gets2
0xB0B1 con_cls
0xB0B5 con_get_cursor_pos
0xB0B9 con_set_cursor_pos
0x9B1D con_imports
0x59F0 con_lib_link
0x864E _ksys_cofflib_getproc
0x5BDB con_init_console_dll
0x5C12 con_init_console_dll_param
0x8638 _ksys_cofflib_load
0x9C9D L.1
0x9CA2 L.2
0x9CA7 L.3
0x9CAC L.4
0x9CB1 L.5
0x9CB9 L.6
0x9CC1 L.7
0x9CC9 L.8
0x9CD1 L.9
0x9CD9 L.10
0x9CE1 L.11
0x9CE9 L.12
0x9CF1 L.13
0x9CF9 L.14
0x9D01 L.15
0x9D09 L.16
0x9D25 L.17
0x9D2D L.18
0x9D35 L.19
0x9D4A L.20
0x9D5B L.21
0x9D72 L.22
0x9D9F L.23
0x9DCF L.24
0x5CA8 formatted_double_special
0x5D8E copy_and_align
0x6059 formatted_double_to_string_scientific
0x6282 formatted_double_to_string
0x69DC formatted_long_to_string
0x86F8 floor
0x8A4A __divdi3
0x8E2A __tcc_cvt_ftol
0x9470 roundl
0x6EB9 formatted_hex_to_string
0x8C3D __udivdi3
0x73EF formatted_octa_to_string
0x9DF5 __is
0x8698 strncpy
0x85E8 .text
0x8600 sysfree
0x8618 sysrealloc
0x8638 .text
0x8690 .text
0x8690 _ksys_exit@0
0x86F8 .text
0x8724 __udivmoddi4
0x9EF9 L.3
0x9F01 L.4
0x9F09 L.5
0x9F11 L.6
0x9F15 L.7
0x9F19 L.8
0x9F21 L.9
0x9F29 L.10
0x9F31 L.11
0x8B4C __moddi3
0x8C6B __umoddi3
0x8C9D __ashrdi3
0x8D22 __lshrdi3
0x8DA6 __ashldi3
0x8E58 __floatundisf
0x8EBC __floatundidf
0x8F20 __floatundixf
0x8F84 __fixunssfdi
0x9072 __fixunsdfdi
0x919C __fixunsxfdi
0x9273 __fixsfdi
0x9319 __fixdfdi
0x93BF __fixxfdi
0x9465 __clear_cache
0x9F39 L.0
0x9F41 L.1
0x9F49 L.2
0x94D8 ceil
0x94D8 .text
.text source code links
0x2EA         WORD a, b, c, d, m[16], i, j;            // MD5 specifies big endian by
0x31D                 m[i] = (data[j]) + (data[j + 1] << 8) + (data[j + 2] << 16) + (
0x374           a = ctx->state[0];  
0x37F         b = ctx->state[1];  
0x38D         c = ctx->state[2];  
0x39B         d = ctx->state[3];  
0x3A9           FF(a,b,c,d,m[0],  7,0xd76aa478);  
0x3D1 
0x3E7         FF(d,a,b,c,m[1], 12,0xe8c7b756);  
0x40F 
0x425         FF(c,d,a,b,m[2], 17,0x242070db);  
0x44D 
0x463         FF(b,c,d,a,m[3], 22,0xc1bdceee);  
0x48B 
0x4A1         FF(a,b,c,d,m[4],  7,0xf57c0faf);  
0x4C9 
0x4DF         FF(d,a,b,c,m[5], 12,0x4787c62a);  
0x507 
0x51D         FF(c,d,a,b,m[6], 17,0xa8304613);  
0x545 
0x55B         FF(b,c,d,a,m[7], 22,0xfd469501);  
0x583 
0x599         FF(a,b,c,d,m[8],  7,0x698098d8);  
0x5C1 
0x5D7         FF(d,a,b,c,m[9], 12,0x8b44f7af);  
0x5FF 
0x615         FF(c,d,a,b,m[10],17,0xffff5bb1);  
0x63D 
0x653         FF(b,c,d,a,m[11],22,0x895cd7be);  
0x67B 
0x691         FF(a,b,c,d,m[12], 7,0x6b901122);  
0x6B9 
0x6CF         FF(d,a,b,c,m[13],12,0xfd987193);  
0x6F7 
0x70D         FF(c,d,a,b,m[14],17,0xa679438e);  
0x735 
0x74B         FF(b,c,d,a,m[15],22,0x49b40821);  
0x773 
0x789           GG(a,b,c,d,m[1],  5,0xf61e2562);  
0x7B1 
0x7C7         GG(d,a,b,c,m[6],  9,0xc040b340);  
0x7EF 
0x805         GG(c,d,a,b,m[11],14,0x265e5a51);  
0x82D 
0x843         GG(b,c,d,a,m[0], 20,0xe9b6c7aa);  
0x86B 
0x881         GG(a,b,c,d,m[5],  5,0xd62f105d);  
0x8A9 
0x8BF         GG(d,a,b,c,m[10], 9,0x02441453);  
0x8E7 
0x8FD         GG(c,d,a,b,m[15],14,0xd8a1e681);  
0x925 
0x93B         GG(b,c,d,a,m[4], 20,0xe7d3fbc8);  
0x963 
0x979         GG(a,b,c,d,m[9],  5,0x21e1cde6);  
0x9A1 
0x9B7         GG(d,a,b,c,m[14], 9,0xc33707d6);  
0x9DF 
0x9F5         GG(c,d,a,b,m[3], 14,0xf4d50d87);  
0xA1D 
0xA33         GG(b,c,d,a,m[8], 20,0x455a14ed);  
0xA5B 
0xA71         GG(a,b,c,d,m[13], 5,0xa9e3e905);  
0xA99 
0xAAF         GG(d,a,b,c,m[2],  9,0xfcefa3f8);  
0xAD7 
0xAED         GG(c,d,a,b,m[7], 14,0x676f02d9);  
0xB15 
0xB2B         GG(b,c,d,a,m[12],20,0x8d2a4c8a);  
0xB53 
0xB69           HH(a,b,c,d,m[5],  4,0xfffa3942);  
0xB89 
0xB9F         HH(d,a,b,c,m[8], 11,0x8771f681);  
0xBBF 
0xBD5         HH(c,d,a,b,m[11],16,0x6d9d6122);  
0xBF5 
0xC0B         HH(b,c,d,a,m[14],23,0xfde5380c);  
0xC2B 
0xC41         HH(a,b,c,d,m[1],  4,0xa4beea44);  
0xC61 
0xC77         HH(d,a,b,c,m[4], 11,0x4bdecfa9);  
0xC97 
0xCAD         HH(c,d,a,b,m[7], 16,0xf6bb4b60);  
0xCCD 
0xCE3         HH(b,c,d,a,m[10],23,0xbebfbc70);  
0xD03 
0xD19         HH(a,b,c,d,m[13], 4,0x289b7ec6);  
0xD39 
0xD4F         HH(d,a,b,c,m[0], 11,0xeaa127fa);  
0xD6F 
0xD85         HH(c,d,a,b,m[3], 16,0xd4ef3085);  
0xDA5 
0xDBB         HH(b,c,d,a,m[6], 23,0x04881d05);  
0xDDB 
0xDF1         HH(a,b,c,d,m[9],  4,0xd9d4d039);  
0xE11 
0xE27         HH(d,a,b,c,m[12],11,0xe6db99e5);  
0xE47 
0xE5D         HH(c,d,a,b,m[15],16,0x1fa27cf8);  
0xE7D 
0xE93         HH(b,c,d,a,m[2], 23,0xc4ac5665);  
0xEB3 
0xEC9           II(a,b,c,d,m[0],  6,0xf4292244);  
0xEEC 
0xF02         II(d,a,b,c,m[7], 10,0x432aff97);  
0xF25 
0xF3B         II(c,d,a,b,m[14],15,0xab9423a7);  
0xF5E 
0xF74         II(b,c,d,a,m[5], 21,0xfc93a039);  
0xF97 
0xFAD         II(a,b,c,d,m[12], 6,0x655b59c3);  
0xFD0 
0xFE6         II(d,a,b,c,m[3], 10,0x8f0ccc92);  
0x1009 
0x101F         II(c,d,a,b,m[10],15,0xffeff47d);  
0x1042 
0x1058         II(b,c,d,a,m[1], 21,0x85845dd1);  
0x107B 
0x1091         II(a,b,c,d,m[8],  6,0x6fa87e4f);  
0x10B4 
0x10CA         II(d,a,b,c,m[15],10,0xfe2ce6e0);  
0x10ED 
0x1103         II(c,d,a,b,m[6], 15,0xa3014314);  
0x1126 
0x113C         II(b,c,d,a,m[13],21,0x4e0811a1);  
0x115F 
0x1175         II(a,b,c,d,m[4],  6,0xf7537e82);  
0x1198 
0x11AE         II(d,a,b,c,m[11],10,0xbd3af235);  
0x11D1 
0x11E7         II(c,d,a,b,m[2], 15,0x2ad7d2bb);  
0x120A 
0x1220         II(b,c,d,a,m[9], 21,0xeb86d391);  
0x1243 
0x1259           ctx->state[0] += a;  
0x1268         ctx->state[1] += b;  
0x127A         ctx->state[2] += c;  
0x128C         ctx->state[3] += d;  
0x12A9         ctx->datalen = 0;  
0x12B6         ctx->bitlen = 0;  
0x12CD         ctx->state[0] = 0x67452301;  
0x12DA         ctx->state[1] = 0xEFCDAB89;  
0x12EA         ctx->state[2] = 0x98BADCFE;  
0x12FA         ctx->state[3] = 0x10325476;  
0x1315         size_t i;            for (i = 0; i < len; ++i) {  
0x1339 
0x1339                 ctx->data[ctx->datalen] = data[i];  
0x1353                 ctx->datalen++;  
0x1360                 if (ctx->datalen == 64) {  
0x1371 
0x1371                         md5_transform(ctx, ctx->data);  
0x1381                         ctx->bitlen += 512;  
0x13BB                         ctx->datalen = 0;  
0x13D8         size_t i;            i = ctx->datalen;  
0x13E3           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x13F4 
0x13F4                 ctx->data[i++] = 0x80;  
0x1409                 while (i < 56)  
0x1415                         ctx->data[i++] = 0x00;  
0x1431         }          else if (ctx->datalen >= 56) {  
0x1442 
0x1442                 ctx->data[i++] = 0x80;  
0x1457                 while (i < 64)  
0x1463                         ctx->data[i++] = 0x00;  
0x147A                 md5_transform(ctx, ctx->data);  
0x148A                 memset(ctx->data, 0, 56);  
0x14A2         }            // Append to the padding the total message's length in bit
0x14EE         ctx->data[56] = ctx->bitlen;  
0x1523         ctx->data[57] = ctx->bitlen >> 8;  
0x1565         ctx->data[58] = ctx->bitlen >> 16;  
0x15A7         ctx->data[59] = ctx->bitlen >> 24;  
0x15E9         ctx->data[60] = ctx->bitlen >> 32;  
0x1623         ctx->data[61] = ctx->bitlen >> 40;  
0x1660         ctx->data[62] = ctx->bitlen >> 48;  
0x169D         ctx->data[63] = ctx->bitlen >> 56;  
0x16DA         md5_transform(ctx, ctx->data);  
0x16EA           // Since this implementation uses little endian byte ordering and MD 
0x170C 
0x170C                 hash[i]      = (ctx->state[0] >> (i * 8)) & 0x000000ff;  
0x173A                 hash[i + 4]  = (ctx->state[1] >> (i * 8)) & 0x000000ff;  
0x177A                 hash[i + 8]  = (ctx->state[2] >> (i * 8)) & 0x000000ff;  
0x17BA                 hash[i + 12] = (ctx->state[3] >> (i * 8)) & 0x000000ff;  
0x180A         WORD a, b, c, d, e, i, j, t, m[80];            for (i = 0, j = 0; i < 1
0x183D                 m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 
0x189D         for ( ; i < 80; ++i) {  
0x18B7 
0x18B7                 m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]);  
0x1925                 m[i] = (m[i] << 1) | (m[i] >> 31);  
0x196E         }            a = ctx->state[0];  
0x1979         b = ctx->state[1];  
0x1987         c = ctx->state[2];  
0x1995         d = ctx->state[3];  
0x19A3         e = ctx->state[4];  
0x19B1           for (i = 0; i < 20; ++i) {  
0x19D3 
0x19D3                 t = ROTLEFT(a, 5) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i]
0x1A28                 e = d;  
0x1A2E                 d = c;  
0x1A34                 c = ROTLEFT(b, 30);  
0x1A45                 b = a;  
0x1A4B                 a = t;  
0x1A56         }          for ( ; i < 40; ++i) {  
0x1A70 
0x1A70                 t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[1] + m[i];  
0x1AB4                 e = d;  
0x1ABA                 d = c;  
0x1AC0                 c = ROTLEFT(b, 30);  
0x1AD1                 b = a;  
0x1AD7                 a = t;  
0x1ADF         }          for ( ; i < 60; ++i) {  
0x1AF9 
0x1AF9                 t = ROTLEFT(a, 5) + ((b & c) ^ (b & d) ^ (c & d))  + e + ctx->k
0x1B58                 e = d;  
0x1B5E                 d = c;  
0x1B64                 c = ROTLEFT(b, 30);  
0x1B75                 b = a;  
0x1B7B                 a = t;  
0x1B86         }          for ( ; i < 80; ++i) {  
0x1BA0 
0x1BA0                 t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[3] + m[i];  
0x1BE4                 e = d;  
0x1BEA                 d = c;  
0x1BF0                 c = ROTLEFT(b, 30);  
0x1C01                 b = a;  
0x1C07                 a = t;  
0x1C0F         }            ctx->state[0] += a;  
0x1C1E         ctx->state[1] += b;  
0x1C30         ctx->state[2] += c;  
0x1C42         ctx->state[3] += d;  
0x1C54         ctx->state[4] += e;  
0x1C71         ctx->datalen = 0;  
0x1C7E         ctx->bitlen = 0;  
0x1C95         ctx->state[0] = 0x67452301;  
0x1CA2         ctx->state[1] = 0xEFCDAB89;  
0x1CB2         ctx->state[2] = 0x98BADCFE;  
0x1CC2         ctx->state[3] = 0x10325476;  
0x1CD2         ctx->state[4] = 0xc3d2e1f0;  
0x1CE2         ctx->k[0] = 0x5a827999;  
0x1CEF         ctx->k[1] = 0x6ed9eba1;  
0x1CFF         ctx->k[2] = 0x8f1bbcdc;  
0x1D0F         ctx->k[3] = 0xca62c1d6;  
0x1D2A         size_t i;            for (i = 0; i < len; ++i) {  
0x1D4E 
0x1D4E                 ctx->data[ctx->datalen] = data[i];  
0x1D68                 ctx->datalen++;  
0x1D75                 if (ctx->datalen == 64) {  
0x1D86 
0x1D86                         sha1_transform(ctx, ctx->data);  
0x1D96                         ctx->bitlen += 512;  
0x1DD0                         ctx->datalen = 0;  
0x1DED         WORD i;            i = ctx->datalen;  
0x1DF8           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x1E09 
0x1E09                 ctx->data[i++] = 0x80;  
0x1E1E                 while (i < 56)  
0x1E2A                         ctx->data[i++] = 0x00;  
0x1E46         }          else {  
0x1E46                 ctx->data[i++] = 0x80;  
0x1E5B                 while (i < 64)  
0x1E67                         ctx->data[i++] = 0x00;  
0x1E7E                 sha1_transform(ctx, ctx->data);  
0x1E8E                 memset(ctx->data, 0, 56);  
0x1EA6         }            // Append to the padding the total message's length in bit
0x1EF2         ctx->data[63] = ctx->bitlen;  
0x1F27         ctx->data[62] = ctx->bitlen >> 8;  
0x1F69         ctx->data[61] = ctx->bitlen >> 16;  
0x1FAB         ctx->data[60] = ctx->bitlen >> 24;  
0x1FED         ctx->data[59] = ctx->bitlen >> 32;  
0x2027         ctx->data[58] = ctx->bitlen >> 40;  
0x2064         ctx->data[57] = ctx->bitlen >> 48;  
0x20A1         ctx->data[56] = ctx->bitlen >> 56;  
0x20DE         sha1_transform(ctx, ctx->data);  
0x20EE           // Since this implementation uses little endian byte ordering and MD 
0x2110 
0x2110                 hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;  
0x213D                 hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;  
0x2170                 hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;  
0x21A9                 hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;  
0x21E2                 hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;  
0x2253   pos_t pos=get_mouse_pos(0);    begin_draw();  
0x2258   sys_create_window(pos.x, pos.y, 200, 60, "Error!", 0xFFFFFFFF, 0x14);  
0x2288   draw_text_sys(msg, 20, 34, 0,   0x90000000);  
0x22AC   end_draw();  
0x22BC    draw_error_box(msg);  
0x22D0    int gui_event;     int pressed_button = 0;     set_event_mask(0xC0000027);  
0x22DE      draw_error_box(msg);  
0x22EA    do  
0x22EA    {  
0x22EA         gui_event = get_os_event();  
0x22F2           switch(gui_event)  
0x22FA         {  
0x22FA         case KOLIBRI_EVENT_NONE:  
0x2308             break;  
0x230D         case KOLIBRI_EVENT_REDRAW:  
0x231B             draw_error_box(msg);  
0x2327             break;  
0x232C         case KOLIBRI_EVENT_KEY:  
0x233A             break;  
0x233F         case KOLIBRI_EVENT_BUTTON:  
0x234D             pressed_button = get_os_button();  
0x2355               switch (pressed_button)  
0x235D             {  
0x235D                 case BTN_EXIT:  
0x236B                 exit(0);  
0x2379                 break;  
0x237E             }          break;  
0x24F5         WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];            for (i = 0
0x2528                 m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 
0x2588         for ( ; i < 64; ++i)  
0x25A2                 m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
0x26FF           a = ctx->state[0];  
0x270A         b = ctx->state[1];  
0x2718         c = ctx->state[2];  
0x2726         d = ctx->state[3];  
0x2734         e = ctx->state[4];  
0x2742         f = ctx->state[5];  
0x2750         g = ctx->state[6];  
0x275E         h = ctx->state[7];  
0x276C           for (i = 0; i < 64; ++i) {  
0x278E 
0x278E                 t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];  
0x280A                 t2 = EP0(a) + MAJ(a,b,c);  
0x2865                 h = g;  
0x286B                 g = f;  
0x2871                 f = e;  
0x2877                 e = d + t1;  
0x2882                 d = c;  
0x2888                 c = b;  
0x288E                 b = a;  
0x2894                 a = t1 + t2;  
0x28A4         }            ctx->state[0] += a;  
0x28B3         ctx->state[1] += b;  
0x28C5         ctx->state[2] += c;  
0x28D7         ctx->state[3] += d;  
0x28E9         ctx->state[4] += e;  
0x28FB         ctx->state[5] += f;  
0x290D         ctx->state[6] += g;  
0x291F         ctx->state[7] += h;  
0x293C         ctx->datalen = 0;  
0x2949         ctx->bitlen = 0;  
0x2960         ctx->state[0] = 0x6a09e667;  
0x296D         ctx->state[1] = 0xbb67ae85;  
0x297D         ctx->state[2] = 0x3c6ef372;  
0x298D         ctx->state[3] = 0xa54ff53a;  
0x299D         ctx->state[4] = 0x510e527f;  
0x29AD         ctx->state[5] = 0x9b05688c;  
0x29BD         ctx->state[6] = 0x1f83d9ab;  
0x29CD         ctx->state[7] = 0x5be0cd19;  
0x29E8         WORD i;            for (i = 0; i < len; ++i) {  
0x2A0C 
0x2A0C                 ctx->data[ctx->datalen] = data[i];  
0x2A26                 ctx->datalen++;  
0x2A33                 if (ctx->datalen == 64) {  
0x2A44 
0x2A44                         sha256_transform(ctx, ctx->data);  
0x2A54                         ctx->bitlen += 512;  
0x2A8E                         ctx->datalen = 0;  
0x2AAB         WORD i;            i = ctx->datalen;  
0x2AB6           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x2AC7 
0x2AC7                 ctx->data[i++] = 0x80;  
0x2ADC                 while (i < 56)  
0x2AE8                         ctx->data[i++] = 0x00;  
0x2B04         }          else {  
0x2B04                 ctx->data[i++] = 0x80;  
0x2B19                 while (i < 64)  
0x2B25                         ctx->data[i++] = 0x00;  
0x2B3C                 sha256_transform(ctx, ctx->data);  
0x2B4C                 memset(ctx->data, 0, 56);  
0x2B64         }            // Append to the padding the total message's length in bit
0x2BB0         ctx->data[63] = ctx->bitlen;  
0x2BE5         ctx->data[62] = ctx->bitlen >> 8;  
0x2C27         ctx->data[61] = ctx->bitlen >> 16;  
0x2C69         ctx->data[60] = ctx->bitlen >> 24;  
0x2CAB         ctx->data[59] = ctx->bitlen >> 32;  
0x2CE5         ctx->data[58] = ctx->bitlen >> 40;  
0x2D22         ctx->data[57] = ctx->bitlen >> 48;  
0x2D5F         ctx->data[56] = ctx->bitlen >> 56;  
0x2D9C         sha256_transform(ctx, ctx->data);  
0x2DAC           // Since this implementation uses little endian byte ordering and SHA
0x2DCE 
0x2DCE                 hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;  
0x2DFB                 hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;  
0x2E2E                 hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;  
0x2E67                 hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;  
0x2EA0                 hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;  
0x2ED9                 hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;  
0x2F12                 hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;  
0x2F4B                 hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;  
0x2F94     edit_box_text_color=BLACK;  
0x2F9F     if(key.code==BACKSPACE && str_pos>0) // –ï—Å–ª–∏ backspace —Ç–æ —É–¥–∞–ª–∏—
0x2FBB     {  
0x2FBB         str_pos--;  
0x2FCC         edit_box_buff[str_pos]='\0';  
0x2FE5       }      else if(str_pos<MAX_HASH_LEN-1) // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω
0x2FF4     {  
0x2FF4         if(strchr(hex,key.code)!=NULL)  
0x3010         {  
0x3010            edit_box_buff[str_pos]=key.code;  
0x3029            str_pos++;  
0x3052     void *p=malloc(size);      if(p==NULL)  
0x305E     {  
0x305E         error_box("Memory allocation error!");  
0x306C         exit(0);  
0x307F     }      else      {  
0x307F         return p;  
0x3092     int input_size;      BYTE *temp_buffer;      temp_buffer=safe_malloc(1024);
0x30A3     MD5_CTX ctx;      md5_init(&ctx);  
0x30AF     while((input_size = fread(temp_buffer, 1, 1024, input)) > 0){  
0x30D7 
0x30D7                 md5_update(&ctx, temp_buffer, input_size);  
0x30ED     }      md5_final(&ctx, hash);  
0x30FD     free(temp_buffer);  
0x3114     int input_size;      BYTE *buffer;      buffer=safe_malloc(1024);  
0x3125     SHA1_CTX ctx;      sha1_init(&ctx);  
0x3131     while((input_size = fread(buffer, 1, 1024, input)) > 0){  
0x3159 
0x3159                 sha1_update(&ctx, buffer, input_size);  
0x316F     }      sha1_final(&ctx, hash);  
0x317F     free(buffer);  
0x3196     int input_size;      BYTE *buffer;      buffer=safe_malloc(1024);  
0x31A7     SHA256_CTX ctx;      sha256_init(&ctx);  
0x31B3     while((input_size = fread(buffer, 1, 1024, input)) > 0){  
0x31DB 
0x31DB                 sha256_update(&ctx, buffer, input_size);  
0x31F1     }      sha256_final(&ctx, hash);  
0x3201     free(buffer);  
0x3218     FILE* input_file;      BYTE *hash;      input_file=fopen(filename,"rb");  
0x322F     hash = safe_malloc(alg);  
0x323E     switch (alg)  
0x3246     {  
0x3246         case MD5_BLOCK_SIZE :  
0x3254             md5_hash(input_file, hash);  
0x3264             md5_flag=1;  
0x326F         break;  
0x3274           case SHA1_BLOCK_SIZE :  
0x3282             sha1_hash(input_file, hash);  
0x3292             sha1_flag=1;  
0x329D         break;  
0x32A2           case SHA256_BLOCK_SIZE :  
0x32B0             sha256_hash(input_file, hash);  
0x32C0             sha256_flag=1;  
0x32CB         break;  
0x32D0     }      fclose(input_file);  
0x32DC     return hash;  
0x32EF     char block[2];      memset(hash_str, 0, MAX_HASH_LEN); // –û—á–∏—â–∞–µ–º —Å
0x3307     for(int i=0; i<hash_size; i++)  
0x332D     {  
0x332D         sprintf(block,"%02x", hash[i]);  
0x334B         strcat(hash_str,block);  
0x335D     }      free(hash);  
0x339C     pos_t win_pos = get_mouse_pos(0); //–ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—
0x33B6     begin_draw(); //–ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ) 
0x33BB     sys_create_window(win_pos.x, win_pos.y, 665, 160, title, 0xFFFFFFFF, 0x14);
0x33EB       draw_bar(10, 121, 525,20, 0x802C8C8C8); // –°–æ–∑–¥–∞—ë–º –ø—Ä—è–º–æ—É–≥–
0x3411     draw_text_sys(edit_box_buff,15, 125, 0, 0x90000000| edit_box_text_color); /
0x343E       define_button((10 << 16) + 60, (30 << 16) + 20, BTN_MD5, GREEN); // –û–ø—
0x345E     define_button((10 << 16) + 60, (60 << 16) + 20, BTN_SHA1, GREEN);// –û–ø—Ä–
0x347E     define_button((10 << 16) + 60, (90 << 16) + 20, BTN_SHA256, GREEN);// –û–ø—
0x349E       draw_text_sys("MD5:", 15, 34, 0,   0x90000000 | sys_color_table.work_butt
0x34CB     draw_text_sys("SHA1:", 15, 64, 0,  0x90000000 | sys_color_table.work_button
0x34F8     draw_text_sys("SHA256:", 15,94, 0, 0x90000000 | sys_color_table.work_button
0x3525       draw_text_sys(hash_str_md5, 80, 34, 0, 0x90000000 | sys_color_table.work_
0x3552     draw_text_sys(hash_str_sha1, 80, 64, 0, 0x90000000 | sys_color_table.work_t
0x357F     draw_text_sys(hash_str_sha256, 80, 94, 0, 0x90000000| sys_color_table.work_
0x35AC       define_button((610 << 16) + 42, (30 << 16) + 20, BTN_COPY_MD5, sys_color_
0x35CD     define_button((610<< 16) + 42, (60 << 16) + 20, BTN_COPY_SHA1, sys_color_ta
0x35EE     define_button((610<< 16) + 42, (90 << 16) + 20, BTN_COPY_SHA256, sys_color_
0x360F       draw_text_sys("copy", 615, 34, 0,   0x90000000 | sys_color_table.work_but
0x363C     draw_text_sys("copy", 615, 64, 0,  0x90000000 | sys_color_table.work_button
0x3669     draw_text_sys("copy", 615, 94, 0, 0x90000000 | sys_color_table.work_button_
0x3696       define_button((592<< 16) + 60, (120 << 16) + 20, BTN_CMP, sys_color_table
0x36B7     draw_text_sys("compare", 595, 124 , 0,0x90000000 | sys_color_table.work_but
0x36E4       define_button((540 << 16) + 45, (120 << 16) + 20, BTN_PASTE, sys_color_ta
0x3705     draw_text_sys("paste", 542, 124 , 0,0x90000000 | sys_color_table.work_butto
0x3732     end_draw();  
0x3742     if(55!=strlen(text))  
0x375B     {  
0x375B         char temp_buffer[MAX_HASH_LEN+12];          *(temp_buffer+4)=0;  
0x3763         *(temp_buffer+8)=1;  
0x376B         strcpy(temp_buffer+12, text);  
0x377B         kol_clip_set(strlen(text)+12, temp_buffer);  
0x37A2   strcpy(str, "Please wait! Calculating checksum...                   ");  
0x37B4   redraw_window();  
0x37C4    print_pending_calc(hash_str_universal);  
0x37D0    sprint_hash(check_sum(alg),hash_str_universal, alg);  
0x37ED    return !strcmp(edit_box_buff, hash_str_universal);  
0x3843    int alg=strlen(edit_box_buff)/2;            switch (alg) // –ï—Å–ª–∏ –≤—ã—á–
0x384B         {  
0x384B         case MD5_BLOCK_SIZE:  
0x3859             if(md5_flag)  
0x3868             {  
0x3868                 return !strcmp(edit_box_buff,hash_str_md5);  
0x38A1             }              else              {  
0x38A1                 return calc_and_cmp(hash_str_md5,alg);  
0x38B8             }          break;  
0x38BD           case SHA1_BLOCK_SIZE:  
0x38CB             if(sha1_flag)  
0x38DA             {  
0x38DA                 return !strcmp(edit_box_buff,hash_str_sha1);  
0x3913             }              else              {  
0x3913                 return calc_and_cmp(hash_str_sha1,alg);  
0x392A             }          break;  
0x392F           case SHA256_BLOCK_SIZE:  
0x393D               if(sha256_flag)  
0x394C             {  
0x394C                 return !strcmp(edit_box_buff,hash_str_sha256);  
0x3985             }              else              {  
0x3985                 return calc_and_cmp(hash_str_sha256,alg);  
0x399C             }          break;  
0x39A1           default:  
0x39A1             return FALSE;  
0x39AB         break;  
0x39BB     strcpy(filename, argv[1]); // –ø–æ–ª—É—á–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞  
0x39D2     if(argc<2) // –ï—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ—Ç —Ç–æ —Å–æ–æ–±—â–∞–µ–º –æ
0x39DE     {  
0x39DE         error_box("No file selected!");  
0x39EC         exit(0);  
0x39FA     }      if(NULL==fopen(filename,"rb")) // –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç –∏–ª–∏ 
0x3A1B     {  
0x3A1B         error_box("File not found!");  
0x3A29         exit(0);  
0x3A3F     }        int gui_event; // –ü–µ—Ä–µ–º–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–±—
0x3A4D     set_event_mask(0xC0000027); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—Å–∫—É —Å–æ–±
0x3A5B     do // –¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π  
0x3A5B     {  
0x3A5B         gui_event = get_os_event(); // –ü–æ–ª—É—á–∞–µ–º —Å–æ–±—ã—Ç–∏–µ  
0x3A63         switch(gui_event) // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è  
0x3A6B         {  
0x3A6B         case KOLIBRI_EVENT_NONE:  
0x3A79             break;  
0x3A7E         case KOLIBRI_EVENT_REDRAW:  
0x3A8C             redraw_window();  
0x3A91             break;  
0x3A96         case KOLIBRI_EVENT_KEY:  
0x3AA4             edit_box(get_key()); // –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∂–∞—Ç—É—é –∫–ª–∞–≤–∏—
0x3AD0             redraw_window();  
0x3AD5             break;  
0x3ADA         case KOLIBRI_EVENT_BUTTON: // –°–æ–±—ã—Ç–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–Ω–æ–
0x3AE8             pressed_button = get_os_button(); // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞ –Ω
0x3AF0             switch (pressed_button) // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∫–∞—è –∫–Ω–æ–ø–∫–∞
0x3AF8             {  
0x3AF8                 case BTN_MD5:  
0x3B06                     print_pending_calc(hash_str_md5);  
0x3B14                     sprint_hash(check_sum(MD5_BLOCK_SIZE),hash_str_md5, MD5_BLO
0x3B37                     redraw_window();  
0x3B3C                 break;  
0x3B41                   case BTN_SHA1:  
0x3B4F                     print_pending_calc(hash_str_sha1);  
0x3B5D                     sprint_hash(check_sum(SHA1_BLOCK_SIZE),hash_str_sha1, SHA1_
0x3B80                     redraw_window();  
0x3B85                 break;  
0x3B8A                   case BTN_SHA256:  
0x3B98                     print_pending_calc(hash_str_sha256);  
0x3BA6                     sprint_hash(check_sum(SHA256_BLOCK_SIZE),hash_str_sha256, S
0x3BC9                     redraw_window();  
0x3BCE                 break;  
0x3BD3                   case BTN_COPY_MD5:  
0x3BE1                     redraw_window();  
0x3BE6                     copy_to_clipboard(hash_str_md5);  
0x3BF4                 break;  
0x3BF9                   case BTN_COPY_SHA1:  
0x3C07                     redraw_window();  
0x3C0C                     copy_to_clipboard(hash_str_sha1);  
0x3C1A                 break;  
0x3C1F                   case BTN_COPY_SHA256:  
0x3C2D                     redraw_window();  
0x3C32                     copy_to_clipboard(hash_str_sha256);  
0x3C40                 break;  
0x3C45                 /*                  case BTN_PASTE:                      paste_
0x3C53                 if(hash_compare())  
0x3C61                 {  
0x3C61                     edit_box_text_color=GREEN; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç
0x3C71                 }                  else                  {  
0x3C71                     edit_box_text_color=RED; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ
0x3C7C                 }                  redraw_window();  
0x3C81                 break;  
0x3C86                   case BTN_QUIT:  
0x3C94                     exit(0);  
0x3CA2                 break;  
0x2393 
0x23AC 
0x23C5 
0x3D50 
0x3D72 
0x242C 
0x245C 
0x246E 
0x2496 
0x24A0 
0x3E32 
0x3E3C 
0x24B3 
0x24BD 
