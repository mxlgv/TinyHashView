.text
0x24 .text
0x9FAD .bss
0x1A1 start
0x1A1 _start
0x39B2 main
0x9FAD __argc
0xA431 __argv
0xA031 __path
0x24 
0x2E1 md5_transform
0x12A0 md5_init
0x130C md5_update
0x13CF md5_final
0x5794 memset
0x24 
0x1801 sha1_transform
0x1C68 sha1_init
0x1D21 sha1_update
0x1DE4 sha1_final
0x24 
0x2222 draw_error_box
0x2453 get_mouse_pos
0x5768 memmove
0x238A begin_draw
0x23BC sys_create_window
0x9559 L.8
0x2423 draw_text_sys
0x23A3 end_draw
0x22B3 error_box
0x24CA set_event_mask
0x248D get_os_event
0x24AA get_os_button
0x5A10 exit
0x24 
0x9561 k
0x24EC sha256_transform
0x2933 sha256_init
0x29DF sha256_update
0x2AA2 sha256_final
0x24 
0xA831 sys_color_table
0x9661 hex
0x9678 hash_str_md5
0x96B9 hash_str_sha1
0x96FA hash_str_sha256
0xA859 edit_box_buff
0xA89A filename
0xAC9A title
0x973D str_pos
0x9741 md5_flag
0x9745 sha1_flag
0x9749 sha256_flag
0x974D edit_box_text_color
0x2F8B edit_box
0x5804 strchr
0x303A safe_malloc
0x474C wtmalloc
0x9751 L.12
0x3089 md5_hash
0x4264 fread
0x4BAF wtfree
0x310B sha1_hash
0x318D sha256_hash
0x320F check_sum
0x976A L.13
0x3F94 fopen
0x3F0C fclose
0x32E6 sprint_hash
0x976D L.14
0x471C sprintf
0x57AC strcat
0x336B redraw_window
0x3DF3 get_mouse_pos
0x9772 L.15
0x3CCF begin_draw
0x3D01 sys_create_window
0x3D8A draw_bar
0x3DC3 draw_text_sys
0x3D68 define_button
0x9785 L.16
0x978A L.17
0x9790 L.18
0x9798 L.19
0x979D L.20
0x97A2 L.21
0x97A7 L.22
0x97AF L.23
0x3CE8 end_draw
0x3739 copy_to_clipboard
0x5954 strlen
0x58C4 strcpy
0x3E9C kol_clip_set
0x3799 print_pending_calc
0x97B5 L.24
0x37BB calc_and_cmp
0x5850 strcmp
0x3821 hash_compare
0x97ED L.25
0x97FF L.26
0x9802 L.27
0x3EC6 get_system_colors
0x3EE7 set_event_mask
0x3E2D get_os_event
0x3E4A get_key
0x46E8 puts
0x3E7C get_os_button
0x9815 errno
0x5900 strdup
0x55C4 _ksys_get_filesize
0x574C memcpy
0x561C _ksys_readfile
0x9819 L.0
0x5C33 con_init_console_dll
0xB0D9 con_write_asciiz
0x7855 format_print
0x9825 __freebase
0x9829 __freetop
0x982D __firstfree
0xB0A5 wtalloc_stat
0x9831 L.3
0x985A L.4
0x986D L.5
0x986F L.6
0x98A4 L.7
0x98D6 L.8
0x98E9 L.9
0x98EB L.10
0x991B L.11
0x992E L.12
0x9930 L.13
0x9964 L.14
0x9994 L.15
0x99D9 L.16
0x99E2 L.17
0x99E4 L.18
0x9A18 L.19
0x9A3C L.20
0x9A61 L.21
0x9A88 L.22
0x9A91 L.23
0x9AB6 L.24
0x9ADD L.25
0x981D c_used
0x9821 c_free
0x5594 debug_out_str
0x5990 __assert_func
0x8640 sysmalloc
0x5002 wtrealloc
0x51C2 wtcalloc
0x5212 wtmalloc_freelist_check
0x5336 wtmalloc_freelist_print
0x53BF wtmalloc_poiner_check
0x5420 wtdump_alloc_stats
0x5578 .text
0x5578 _ksys_debug_out
0x55C4 .text
0x566C _ksys_rewritefile
0x56B8 _ksys_appendtofile
0x574C .text
0x5794 .text
0x9B05 L.2
0x9B2D L.3
0x8610 snprintf
0x59D6 __trace_func
0xB0C9 __console_initdll_status
0xB0D1 con_exit
0x86E8 _ksys_exit
0x9B51 L.0
0x9B61 L.1
0x9BD1 L.2
0x9BD7 L.3
0x9BDF L.4
0x9BE8 L.5
0x9BF9 L.6
0x9C0A L.7
0x9C15 L.8
0x9C1E L.9
0x9C2C L.10
0x9C3A L.11
0x9C44 L.12
0x9C4E L.13
0x9C59 L.14
0x9C62 L.15
0x9C6C L.16
0x9C80 L.17
0x9C96 L.18
0x9CAC L.19
0x9CB4 L.20
0x9CC7 L.21
0x9CDA L.22
0x9CE8 L.23
0x9B4D con_caption
0xB0C5 con_dll_ver
0x9B5D con_dllname
0xB0CD con_init
0xB0D5 con_set_title
0xB0DD con_write_string
0xB0E1 con_printf
0xB0E5 con_get_flags
0xB0E9 con_set_flags
0xB0ED con_get_font_height
0xB0F1 con_get_cursor_height
0xB0F5 con_set_cursor_height
0xB0F9 con_getch
0xB0FD con_getch2
0xB101 con_kbhit
0xB105 con_gets
0xB109 con_gets2
0xB10D con_cls
0xB111 con_get_cursor_pos
0xB115 con_set_cursor_pos
0x9B79 con_imports
0x5A48 con_lib_link
0x86A6 _ksys_cofflib_getproc
0x5C6A con_init_console_dll_param
0x8690 _ksys_cofflib_load
0x9CF9 L.1
0x9CFE L.2
0x9D03 L.3
0x9D08 L.4
0x9D0D L.5
0x9D15 L.6
0x9D1D L.7
0x9D25 L.8
0x9D2D L.9
0x9D35 L.10
0x9D3D L.11
0x9D45 L.12
0x9D4D L.13
0x9D55 L.14
0x9D5D L.15
0x9D65 L.16
0x9D81 L.17
0x9D89 L.18
0x9D91 L.19
0x9DA6 L.20
0x9DB7 L.21
0x9DCE L.22
0x9DFB L.23
0x9E2B L.24
0x5D00 formatted_double_special
0x5DE6 copy_and_align
0x60B1 formatted_double_to_string_scientific
0x62DA formatted_double_to_string
0x6A34 formatted_long_to_string
0x8750 floor
0x8AA2 __divdi3
0x8E82 __tcc_cvt_ftol
0x94C8 roundl
0x6F11 formatted_hex_to_string
0x8C95 __udivdi3
0x7447 formatted_octa_to_string
0x9E51 __is
0x86F0 strncpy
0x8640 .text
0x8658 sysfree
0x8670 sysrealloc
0x8690 .text
0x86E8 .text
0x86E8 _ksys_exit@0
0x8750 .text
0x877C __udivmoddi4
0x9F55 L.3
0x9F5D L.4
0x9F65 L.5
0x9F6D L.6
0x9F71 L.7
0x9F75 L.8
0x9F7D L.9
0x9F85 L.10
0x9F8D L.11
0x8BA4 __moddi3
0x8CC3 __umoddi3
0x8CF5 __ashrdi3
0x8D7A __lshrdi3
0x8DFE __ashldi3
0x8EB0 __floatundisf
0x8F14 __floatundidf
0x8F78 __floatundixf
0x8FDC __fixunssfdi
0x90CA __fixunsdfdi
0x91F4 __fixunsxfdi
0x92CB __fixsfdi
0x9371 __fixdfdi
0x9417 __fixxfdi
0x94BD __clear_cache
0x9F95 L.0
0x9F9D L.1
0x9FA5 L.2
0x9530 ceil
0x9530 .text
.text source code links
0x2EA         WORD a, b, c, d, m[16], i, j;            // MD5 specifies big endian by
0x31D                 m[i] = (data[j]) + (data[j + 1] << 8) + (data[j + 2] << 16) + (
0x374           a = ctx->state[0];  
0x37F         b = ctx->state[1];  
0x38D         c = ctx->state[2];  
0x39B         d = ctx->state[3];  
0x3A9           FF(a,b,c,d,m[0],  7,0xd76aa478);  
0x3D1 
0x3E7         FF(d,a,b,c,m[1], 12,0xe8c7b756);  
0x40F 
0x425         FF(c,d,a,b,m[2], 17,0x242070db);  
0x44D 
0x463         FF(b,c,d,a,m[3], 22,0xc1bdceee);  
0x48B 
0x4A1         FF(a,b,c,d,m[4],  7,0xf57c0faf);  
0x4C9 
0x4DF         FF(d,a,b,c,m[5], 12,0x4787c62a);  
0x507 
0x51D         FF(c,d,a,b,m[6], 17,0xa8304613);  
0x545 
0x55B         FF(b,c,d,a,m[7], 22,0xfd469501);  
0x583 
0x599         FF(a,b,c,d,m[8],  7,0x698098d8);  
0x5C1 
0x5D7         FF(d,a,b,c,m[9], 12,0x8b44f7af);  
0x5FF 
0x615         FF(c,d,a,b,m[10],17,0xffff5bb1);  
0x63D 
0x653         FF(b,c,d,a,m[11],22,0x895cd7be);  
0x67B 
0x691         FF(a,b,c,d,m[12], 7,0x6b901122);  
0x6B9 
0x6CF         FF(d,a,b,c,m[13],12,0xfd987193);  
0x6F7 
0x70D         FF(c,d,a,b,m[14],17,0xa679438e);  
0x735 
0x74B         FF(b,c,d,a,m[15],22,0x49b40821);  
0x773 
0x789           GG(a,b,c,d,m[1],  5,0xf61e2562);  
0x7B1 
0x7C7         GG(d,a,b,c,m[6],  9,0xc040b340);  
0x7EF 
0x805         GG(c,d,a,b,m[11],14,0x265e5a51);  
0x82D 
0x843         GG(b,c,d,a,m[0], 20,0xe9b6c7aa);  
0x86B 
0x881         GG(a,b,c,d,m[5],  5,0xd62f105d);  
0x8A9 
0x8BF         GG(d,a,b,c,m[10], 9,0x02441453);  
0x8E7 
0x8FD         GG(c,d,a,b,m[15],14,0xd8a1e681);  
0x925 
0x93B         GG(b,c,d,a,m[4], 20,0xe7d3fbc8);  
0x963 
0x979         GG(a,b,c,d,m[9],  5,0x21e1cde6);  
0x9A1 
0x9B7         GG(d,a,b,c,m[14], 9,0xc33707d6);  
0x9DF 
0x9F5         GG(c,d,a,b,m[3], 14,0xf4d50d87);  
0xA1D 
0xA33         GG(b,c,d,a,m[8], 20,0x455a14ed);  
0xA5B 
0xA71         GG(a,b,c,d,m[13], 5,0xa9e3e905);  
0xA99 
0xAAF         GG(d,a,b,c,m[2],  9,0xfcefa3f8);  
0xAD7 
0xAED         GG(c,d,a,b,m[7], 14,0x676f02d9);  
0xB15 
0xB2B         GG(b,c,d,a,m[12],20,0x8d2a4c8a);  
0xB53 
0xB69           HH(a,b,c,d,m[5],  4,0xfffa3942);  
0xB89 
0xB9F         HH(d,a,b,c,m[8], 11,0x8771f681);  
0xBBF 
0xBD5         HH(c,d,a,b,m[11],16,0x6d9d6122);  
0xBF5 
0xC0B         HH(b,c,d,a,m[14],23,0xfde5380c);  
0xC2B 
0xC41         HH(a,b,c,d,m[1],  4,0xa4beea44);  
0xC61 
0xC77         HH(d,a,b,c,m[4], 11,0x4bdecfa9);  
0xC97 
0xCAD         HH(c,d,a,b,m[7], 16,0xf6bb4b60);  
0xCCD 
0xCE3         HH(b,c,d,a,m[10],23,0xbebfbc70);  
0xD03 
0xD19         HH(a,b,c,d,m[13], 4,0x289b7ec6);  
0xD39 
0xD4F         HH(d,a,b,c,m[0], 11,0xeaa127fa);  
0xD6F 
0xD85         HH(c,d,a,b,m[3], 16,0xd4ef3085);  
0xDA5 
0xDBB         HH(b,c,d,a,m[6], 23,0x04881d05);  
0xDDB 
0xDF1         HH(a,b,c,d,m[9],  4,0xd9d4d039);  
0xE11 
0xE27         HH(d,a,b,c,m[12],11,0xe6db99e5);  
0xE47 
0xE5D         HH(c,d,a,b,m[15],16,0x1fa27cf8);  
0xE7D 
0xE93         HH(b,c,d,a,m[2], 23,0xc4ac5665);  
0xEB3 
0xEC9           II(a,b,c,d,m[0],  6,0xf4292244);  
0xEEC 
0xF02         II(d,a,b,c,m[7], 10,0x432aff97);  
0xF25 
0xF3B         II(c,d,a,b,m[14],15,0xab9423a7);  
0xF5E 
0xF74         II(b,c,d,a,m[5], 21,0xfc93a039);  
0xF97 
0xFAD         II(a,b,c,d,m[12], 6,0x655b59c3);  
0xFD0 
0xFE6         II(d,a,b,c,m[3], 10,0x8f0ccc92);  
0x1009 
0x101F         II(c,d,a,b,m[10],15,0xffeff47d);  
0x1042 
0x1058         II(b,c,d,a,m[1], 21,0x85845dd1);  
0x107B 
0x1091         II(a,b,c,d,m[8],  6,0x6fa87e4f);  
0x10B4 
0x10CA         II(d,a,b,c,m[15],10,0xfe2ce6e0);  
0x10ED 
0x1103         II(c,d,a,b,m[6], 15,0xa3014314);  
0x1126 
0x113C         II(b,c,d,a,m[13],21,0x4e0811a1);  
0x115F 
0x1175         II(a,b,c,d,m[4],  6,0xf7537e82);  
0x1198 
0x11AE         II(d,a,b,c,m[11],10,0xbd3af235);  
0x11D1 
0x11E7         II(c,d,a,b,m[2], 15,0x2ad7d2bb);  
0x120A 
0x1220         II(b,c,d,a,m[9], 21,0xeb86d391);  
0x1243 
0x1259           ctx->state[0] += a;  
0x1268         ctx->state[1] += b;  
0x127A         ctx->state[2] += c;  
0x128C         ctx->state[3] += d;  
0x12A9         ctx->datalen = 0;  
0x12B6         ctx->bitlen = 0;  
0x12CD         ctx->state[0] = 0x67452301;  
0x12DA         ctx->state[1] = 0xEFCDAB89;  
0x12EA         ctx->state[2] = 0x98BADCFE;  
0x12FA         ctx->state[3] = 0x10325476;  
0x1315         size_t i;            for (i = 0; i < len; ++i) {  
0x1339 
0x1339                 ctx->data[ctx->datalen] = data[i];  
0x1353                 ctx->datalen++;  
0x1360                 if (ctx->datalen == 64) {  
0x1371 
0x1371                         md5_transform(ctx, ctx->data);  
0x1381                         ctx->bitlen += 512;  
0x13BB                         ctx->datalen = 0;  
0x13D8         size_t i;            i = ctx->datalen;  
0x13E3           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x13F4 
0x13F4                 ctx->data[i++] = 0x80;  
0x1409                 while (i < 56)  
0x1415                         ctx->data[i++] = 0x00;  
0x1431         }          else if (ctx->datalen >= 56) {  
0x1442 
0x1442                 ctx->data[i++] = 0x80;  
0x1457                 while (i < 64)  
0x1463                         ctx->data[i++] = 0x00;  
0x147A                 md5_transform(ctx, ctx->data);  
0x148A                 memset(ctx->data, 0, 56);  
0x14A2         }            // Append to the padding the total message's length in bit
0x14EE         ctx->data[56] = ctx->bitlen;  
0x1523         ctx->data[57] = ctx->bitlen >> 8;  
0x1565         ctx->data[58] = ctx->bitlen >> 16;  
0x15A7         ctx->data[59] = ctx->bitlen >> 24;  
0x15E9         ctx->data[60] = ctx->bitlen >> 32;  
0x1623         ctx->data[61] = ctx->bitlen >> 40;  
0x1660         ctx->data[62] = ctx->bitlen >> 48;  
0x169D         ctx->data[63] = ctx->bitlen >> 56;  
0x16DA         md5_transform(ctx, ctx->data);  
0x16EA           // Since this implementation uses little endian byte ordering and MD 
0x170C 
0x170C                 hash[i]      = (ctx->state[0] >> (i * 8)) & 0x000000ff;  
0x173A                 hash[i + 4]  = (ctx->state[1] >> (i * 8)) & 0x000000ff;  
0x177A                 hash[i + 8]  = (ctx->state[2] >> (i * 8)) & 0x000000ff;  
0x17BA                 hash[i + 12] = (ctx->state[3] >> (i * 8)) & 0x000000ff;  
0x180A         WORD a, b, c, d, e, i, j, t, m[80];            for (i = 0, j = 0; i < 1
0x183D                 m[i] = (data[j] << 24) + (data[j + 1] << 16) + (data[j + 2] << 
0x189D         for ( ; i < 80; ++i) {  
0x18B7 
0x18B7                 m[i] = (m[i - 3] ^ m[i - 8] ^ m[i - 14] ^ m[i - 16]);  
0x1925                 m[i] = (m[i] << 1) | (m[i] >> 31);  
0x196E         }            a = ctx->state[0];  
0x1979         b = ctx->state[1];  
0x1987         c = ctx->state[2];  
0x1995         d = ctx->state[3];  
0x19A3         e = ctx->state[4];  
0x19B1           for (i = 0; i < 20; ++i) {  
0x19D3 
0x19D3                 t = ROTLEFT(a, 5) + ((b & c) ^ (~b & d)) + e + ctx->k[0] + m[i]
0x1A28                 e = d;  
0x1A2E                 d = c;  
0x1A34                 c = ROTLEFT(b, 30);  
0x1A45                 b = a;  
0x1A4B                 a = t;  
0x1A56         }          for ( ; i < 40; ++i) {  
0x1A70 
0x1A70                 t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[1] + m[i];  
0x1AB4                 e = d;  
0x1ABA                 d = c;  
0x1AC0                 c = ROTLEFT(b, 30);  
0x1AD1                 b = a;  
0x1AD7                 a = t;  
0x1ADF         }          for ( ; i < 60; ++i) {  
0x1AF9 
0x1AF9                 t = ROTLEFT(a, 5) + ((b & c) ^ (b & d) ^ (c & d))  + e + ctx->k
0x1B58                 e = d;  
0x1B5E                 d = c;  
0x1B64                 c = ROTLEFT(b, 30);  
0x1B75                 b = a;  
0x1B7B                 a = t;  
0x1B86         }          for ( ; i < 80; ++i) {  
0x1BA0 
0x1BA0                 t = ROTLEFT(a, 5) + (b ^ c ^ d) + e + ctx->k[3] + m[i];  
0x1BE4                 e = d;  
0x1BEA                 d = c;  
0x1BF0                 c = ROTLEFT(b, 30);  
0x1C01                 b = a;  
0x1C07                 a = t;  
0x1C0F         }            ctx->state[0] += a;  
0x1C1E         ctx->state[1] += b;  
0x1C30         ctx->state[2] += c;  
0x1C42         ctx->state[3] += d;  
0x1C54         ctx->state[4] += e;  
0x1C71         ctx->datalen = 0;  
0x1C7E         ctx->bitlen = 0;  
0x1C95         ctx->state[0] = 0x67452301;  
0x1CA2         ctx->state[1] = 0xEFCDAB89;  
0x1CB2         ctx->state[2] = 0x98BADCFE;  
0x1CC2         ctx->state[3] = 0x10325476;  
0x1CD2         ctx->state[4] = 0xc3d2e1f0;  
0x1CE2         ctx->k[0] = 0x5a827999;  
0x1CEF         ctx->k[1] = 0x6ed9eba1;  
0x1CFF         ctx->k[2] = 0x8f1bbcdc;  
0x1D0F         ctx->k[3] = 0xca62c1d6;  
0x1D2A         size_t i;            for (i = 0; i < len; ++i) {  
0x1D4E 
0x1D4E                 ctx->data[ctx->datalen] = data[i];  
0x1D68                 ctx->datalen++;  
0x1D75                 if (ctx->datalen == 64) {  
0x1D86 
0x1D86                         sha1_transform(ctx, ctx->data);  
0x1D96                         ctx->bitlen += 512;  
0x1DD0                         ctx->datalen = 0;  
0x1DED         WORD i;            i = ctx->datalen;  
0x1DF8           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x1E09 
0x1E09                 ctx->data[i++] = 0x80;  
0x1E1E                 while (i < 56)  
0x1E2A                         ctx->data[i++] = 0x00;  
0x1E46         }          else {  
0x1E46                 ctx->data[i++] = 0x80;  
0x1E5B                 while (i < 64)  
0x1E67                         ctx->data[i++] = 0x00;  
0x1E7E                 sha1_transform(ctx, ctx->data);  
0x1E8E                 memset(ctx->data, 0, 56);  
0x1EA6         }            // Append to the padding the total message's length in bit
0x1EF2         ctx->data[63] = ctx->bitlen;  
0x1F27         ctx->data[62] = ctx->bitlen >> 8;  
0x1F69         ctx->data[61] = ctx->bitlen >> 16;  
0x1FAB         ctx->data[60] = ctx->bitlen >> 24;  
0x1FED         ctx->data[59] = ctx->bitlen >> 32;  
0x2027         ctx->data[58] = ctx->bitlen >> 40;  
0x2064         ctx->data[57] = ctx->bitlen >> 48;  
0x20A1         ctx->data[56] = ctx->bitlen >> 56;  
0x20DE         sha1_transform(ctx, ctx->data);  
0x20EE           // Since this implementation uses little endian byte ordering and MD 
0x2110 
0x2110                 hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;  
0x213D                 hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;  
0x2170                 hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;  
0x21A9                 hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;  
0x21E2                 hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;  
0x2253   pos_t pos=get_mouse_pos(0);    begin_draw();  
0x2258   sys_create_window(pos.x, pos.y, 200, 60, "Error!", 0xFFFFFFFF, 0x14);  
0x2288   draw_text_sys(msg, 20, 34, 0,   0x90000000);  
0x22AC   end_draw();  
0x22BC    draw_error_box(msg);  
0x22D0    int gui_event;     int pressed_button = 0;     set_event_mask(0xC0000027);  
0x22DE      draw_error_box(msg);  
0x22EA    do  
0x22EA    {  
0x22EA         gui_event = get_os_event();  
0x22F2           switch(gui_event)  
0x22FA         {  
0x22FA         case KOLIBRI_EVENT_NONE:  
0x2308             break;  
0x230D         case KOLIBRI_EVENT_REDRAW:  
0x231B             draw_error_box(msg);  
0x2327             break;  
0x232C         case KOLIBRI_EVENT_KEY:  
0x233A             break;  
0x233F         case KOLIBRI_EVENT_BUTTON:  
0x234D             pressed_button = get_os_button();  
0x2355               switch (pressed_button)  
0x235D             {  
0x235D                 case BTN_EXIT:  
0x236B                 exit(0);  
0x2379                 break;  
0x237E             }          break;  
0x24F5         WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];            for (i = 0
0x2528                 m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 
0x2588         for ( ; i < 64; ++i)  
0x25A2                 m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
0x26FF           a = ctx->state[0];  
0x270A         b = ctx->state[1];  
0x2718         c = ctx->state[2];  
0x2726         d = ctx->state[3];  
0x2734         e = ctx->state[4];  
0x2742         f = ctx->state[5];  
0x2750         g = ctx->state[6];  
0x275E         h = ctx->state[7];  
0x276C           for (i = 0; i < 64; ++i) {  
0x278E 
0x278E                 t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];  
0x280A                 t2 = EP0(a) + MAJ(a,b,c);  
0x2865                 h = g;  
0x286B                 g = f;  
0x2871                 f = e;  
0x2877                 e = d + t1;  
0x2882                 d = c;  
0x2888                 c = b;  
0x288E                 b = a;  
0x2894                 a = t1 + t2;  
0x28A4         }            ctx->state[0] += a;  
0x28B3         ctx->state[1] += b;  
0x28C5         ctx->state[2] += c;  
0x28D7         ctx->state[3] += d;  
0x28E9         ctx->state[4] += e;  
0x28FB         ctx->state[5] += f;  
0x290D         ctx->state[6] += g;  
0x291F         ctx->state[7] += h;  
0x293C         ctx->datalen = 0;  
0x2949         ctx->bitlen = 0;  
0x2960         ctx->state[0] = 0x6a09e667;  
0x296D         ctx->state[1] = 0xbb67ae85;  
0x297D         ctx->state[2] = 0x3c6ef372;  
0x298D         ctx->state[3] = 0xa54ff53a;  
0x299D         ctx->state[4] = 0x510e527f;  
0x29AD         ctx->state[5] = 0x9b05688c;  
0x29BD         ctx->state[6] = 0x1f83d9ab;  
0x29CD         ctx->state[7] = 0x5be0cd19;  
0x29E8         WORD i;            for (i = 0; i < len; ++i) {  
0x2A0C 
0x2A0C                 ctx->data[ctx->datalen] = data[i];  
0x2A26                 ctx->datalen++;  
0x2A33                 if (ctx->datalen == 64) {  
0x2A44 
0x2A44                         sha256_transform(ctx, ctx->data);  
0x2A54                         ctx->bitlen += 512;  
0x2A8E                         ctx->datalen = 0;  
0x2AAB         WORD i;            i = ctx->datalen;  
0x2AB6           // Pad whatever data is left in the buffer.          if (ctx->datalen
0x2AC7 
0x2AC7                 ctx->data[i++] = 0x80;  
0x2ADC                 while (i < 56)  
0x2AE8                         ctx->data[i++] = 0x00;  
0x2B04         }          else {  
0x2B04                 ctx->data[i++] = 0x80;  
0x2B19                 while (i < 64)  
0x2B25                         ctx->data[i++] = 0x00;  
0x2B3C                 sha256_transform(ctx, ctx->data);  
0x2B4C                 memset(ctx->data, 0, 56);  
0x2B64         }            // Append to the padding the total message's length in bit
0x2BB0         ctx->data[63] = ctx->bitlen;  
0x2BE5         ctx->data[62] = ctx->bitlen >> 8;  
0x2C27         ctx->data[61] = ctx->bitlen >> 16;  
0x2C69         ctx->data[60] = ctx->bitlen >> 24;  
0x2CAB         ctx->data[59] = ctx->bitlen >> 32;  
0x2CE5         ctx->data[58] = ctx->bitlen >> 40;  
0x2D22         ctx->data[57] = ctx->bitlen >> 48;  
0x2D5F         ctx->data[56] = ctx->bitlen >> 56;  
0x2D9C         sha256_transform(ctx, ctx->data);  
0x2DAC           // Since this implementation uses little endian byte ordering and SHA
0x2DCE 
0x2DCE                 hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;  
0x2DFB                 hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;  
0x2E2E                 hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;  
0x2E67                 hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;  
0x2EA0                 hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;  
0x2ED9                 hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;  
0x2F12                 hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;  
0x2F4B                 hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;  
0x2F94     edit_box_text_color=BLACK;  
0x2F9F     if(key.code==BACKSPACE && str_pos>0) // –ï—Å–ª–∏ backspace —Ç–æ —É–¥–∞–ª–∏—
0x2FBB     {  
0x2FBB         str_pos--;  
0x2FCC         edit_box_buff[str_pos]='\0';  
0x2FE5       }      else if(str_pos<MAX_HASH_LEN-1) // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª–∏–Ω
0x2FF4     {  
0x2FF4         if(strchr(hex,key.code)!=NULL)  
0x3010         {  
0x3010            edit_box_buff[str_pos]=key.code;  
0x3029            str_pos++;  
0x3052     void *p=malloc(size);      if(p==NULL)  
0x305E     {  
0x305E         error_box("Memory allocation error!");  
0x306C         exit(0);  
0x307F     }      else      {  
0x307F         return p;  
0x3092     int input_size;      BYTE *temp_buffer;      temp_buffer=safe_malloc(1024);
0x30A3     MD5_CTX ctx;      md5_init(&ctx);  
0x30AF     while((input_size = fread(temp_buffer, 1, 1024, input)) > 0){  
0x30D7 
0x30D7                 md5_update(&ctx, temp_buffer, input_size);  
0x30ED     }      md5_final(&ctx, hash);  
0x30FD     free(temp_buffer);  
0x3114     int input_size;      BYTE *buffer;      buffer=safe_malloc(1024);  
0x3125     SHA1_CTX ctx;      sha1_init(&ctx);  
0x3131     while((input_size = fread(buffer, 1, 1024, input)) > 0){  
0x3159 
0x3159                 sha1_update(&ctx, buffer, input_size);  
0x316F     }      sha1_final(&ctx, hash);  
0x317F     free(buffer);  
0x3196     int input_size;      BYTE *buffer;      buffer=safe_malloc(1024);  
0x31A7     SHA256_CTX ctx;      sha256_init(&ctx);  
0x31B3     while((input_size = fread(buffer, 1, 1024, input)) > 0){  
0x31DB 
0x31DB                 sha256_update(&ctx, buffer, input_size);  
0x31F1     }      sha256_final(&ctx, hash);  
0x3201     free(buffer);  
0x3218     FILE* input_file;      BYTE *hash;      input_file=fopen(filename,"rb");  
0x322F     hash = safe_malloc(alg);  
0x323E     switch (alg)  
0x3246     {  
0x3246         case MD5_BLOCK_SIZE :  
0x3254             md5_hash(input_file, hash);  
0x3264             md5_flag=1;  
0x326F         break;  
0x3274           case SHA1_BLOCK_SIZE :  
0x3282             sha1_hash(input_file, hash);  
0x3292             sha1_flag=1;  
0x329D         break;  
0x32A2           case SHA256_BLOCK_SIZE :  
0x32B0             sha256_hash(input_file, hash);  
0x32C0             sha256_flag=1;  
0x32CB         break;  
0x32D0     }      fclose(input_file);  
0x32DC     return hash;  
0x32EF     char block[2];      memset(hash_str, 0, MAX_HASH_LEN); // –û—á–∏—â–∞–µ–º —Å
0x3307     for(int i=0; i<hash_size; i++)  
0x332D     {  
0x332D         sprintf(block,"%02x", hash[i]);  
0x334B         strcat(hash_str,block);  
0x335D     }      free(hash);  
0x339C     pos_t win_pos = get_mouse_pos(0); //–ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—
0x33B6     begin_draw(); //–ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ) 
0x33BB     sys_create_window(win_pos.x, win_pos.y, 665, 160, title, 0xFFFFFFFF, 0x14);
0x33EB       draw_bar(10, 121, 525,20, 0x802C8C8C8); // –°–æ–∑–¥–∞—ë–º –ø—Ä—è–º–æ—É–≥–
0x3411     draw_text_sys(edit_box_buff,15, 125, 0, 0x90000000| edit_box_text_color); /
0x343E        define_button((10 << 16) + 60, (30 << 16) + 20, BTN_MD5, GREEN); // –û–ø
0x345E     define_button((10 << 16) + 60, (60 << 16) + 20, BTN_SHA1, GREEN);// –û–ø—Ä–
0x347E     define_button((10 << 16) + 60, (90 << 16) + 20, BTN_SHA256, GREEN);// –û–ø—
0x349E       draw_text_sys("MD5:", 15, 34, 0,   0x90000000 | sys_color_table.work_butt
0x34CB     draw_text_sys("SHA1:", 15, 64, 0,  0x90000000 | sys_color_table.work_button
0x34F8     draw_text_sys("SHA256:", 15,94, 0, 0x90000000 | sys_color_table.work_button
0x3525       draw_text_sys(hash_str_md5, 80, 34, 0, 0x90000000 | sys_color_table.work_
0x3552     draw_text_sys(hash_str_sha1, 80, 64, 0, 0x90000000 | sys_color_table.work_t
0x357F     draw_text_sys(hash_str_sha256, 80, 94, 0, 0x90000000| sys_color_table.work_
0x35AC       define_button((610 << 16) + 42, (30 << 16) + 20, BTN_COPY_MD5, sys_color_
0x35CD     define_button((610<< 16) + 42, (60 << 16) + 20, BTN_COPY_SHA1, sys_color_ta
0x35EE     define_button((610<< 16) + 42, (90 << 16) + 20, BTN_COPY_SHA256, sys_color_
0x360F       draw_text_sys("copy", 615, 34, 0,   0x90000000 | sys_color_table.work_but
0x363C     draw_text_sys("copy", 615, 64, 0,  0x90000000 | sys_color_table.work_button
0x3669     draw_text_sys("copy", 615, 94, 0, 0x90000000 | sys_color_table.work_button_
0x3696       define_button((592<< 16) + 60, (120 << 16) + 20, BTN_CMP, sys_color_table
0x36B7     draw_text_sys("compare", 595, 124 , 0,0x90000000 | sys_color_table.work_but
0x36E4       define_button((540 << 16) + 45, (120 << 16) + 20, BTN_PASTE, sys_color_ta
0x3705     draw_text_sys("paste", 542, 124 , 0,0x90000000 | sys_color_table.work_butto
0x3732     end_draw();  
0x3742     if(55!=strlen(text))  
0x375B     {  
0x375B         char temp_buffer[MAX_HASH_LEN+12];          *(temp_buffer+4)=0;  
0x3763         *(temp_buffer+8)=1;  
0x376B         strcpy(temp_buffer+12, text);  
0x377B         kol_clip_set(strlen(text)+12, temp_buffer);  
0x37A2   strcpy(str, "Please wait! Calculating checksum...                   ");  
0x37B4   redraw_window();  
0x37C4    print_pending_calc(hash_str_universal);  
0x37D0    sprint_hash(check_sum(alg),hash_str_universal, alg);  
0x37ED    return !strcmp(edit_box_buff, hash_str_universal);  
0x3843    int alg=strlen(edit_box_buff)/2;     if(md5_flag) //–ï—Å–ª–∏ —É–∂–µ –≤—ã—á–∏
0x3852     {  
0x3852         return !strcmp(edit_box_buff,hash_str_md5);  
0x388B     }      else if(sha1_flag)  
0x389A     {  
0x389A         return !strcmp(edit_box_buff,hash_str_sha1);  
0x38D3     }      else if(sha256_flag)  
0x38E2     {  
0x38E2         return !strcmp(edit_box_buff, hash_str_sha256);  
0x391B     }      else      {  
0x391B         switch (alg) // –ï—Å–ª–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –µ—â—ë –Ω–µ–±—ã–ª–æ  
0x3923         {  
0x3923         case MD5_BLOCK_SIZE:  
0x3931             return calc_and_cmp(hash_str_md5,alg);  
0x3948         break;  
0x394D           case SHA1_BLOCK_SIZE:  
0x395B             return calc_and_cmp(hash_str_sha1,alg);  
0x3972         break;  
0x3977           case SHA256_BLOCK_SIZE:  
0x3985             return calc_and_cmp(hash_str_sha256,alg);  
0x399C         break;  
0x39A1           default:  
0x39A1             return FALSE;  
0x39AB         break;  
0x39BB     strcpy(filename, argv[1]); // –ø–æ–ª—É—á–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞  
0x39D2     if(argc<2) // –ï—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ—Ç —Ç–æ —Å–æ–æ–±—â–∞–µ–º –æ
0x39DE     {  
0x39DE         error_box("No file selected!");  
0x39EC         exit(0);  
0x39FA     }      if(NULL==fopen(filename,"rb")) // –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç –∏–ª–∏ 
0x3A1B     {  
0x3A1B         error_box("File not found!");  
0x3A29         exit(0);  
0x3A3F     }        int gui_event; // –ü–µ—Ä–µ–º–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–±—
0x3A4D     set_event_mask(0xC0000027); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—Å–∫—É —Å–æ–±
0x3A5B     do // –¶–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π  
0x3A5B     {  
0x3A5B         gui_event = get_os_event(); // –ü–æ–ª—É—á–∞–µ–º —Å–æ–±—ã—Ç–∏–µ  
0x3A63         switch(gui_event) // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏—è  
0x3A6B         {  
0x3A6B         case KOLIBRI_EVENT_NONE:  
0x3A79             break;  
0x3A7E         case KOLIBRI_EVENT_REDRAW:  
0x3A8C             redraw_window();  
0x3A91             break;  
0x3A96         case KOLIBRI_EVENT_KEY:  
0x3AA4             edit_box(get_key()); // –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∂–∞—Ç—É—é –∫–ª–∞–≤–∏—
0x3AD0             redraw_window();  
0x3AD5             puts(edit_box_buff);  
0x3AE3             break;  
0x3AE8         case KOLIBRI_EVENT_BUTTON: // –°–æ–±—ã—Ç–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–Ω–æ–
0x3AF6             pressed_button = get_os_button(); // –ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞ –Ω
0x3AFE             switch (pressed_button) // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∫–∞—è –∫–Ω–æ–ø–∫–∞
0x3B06             {  
0x3B06                 case BTN_MD5:  
0x3B14                     print_pending_calc(hash_str_md5);  
0x3B22                     sprint_hash(check_sum(MD5_BLOCK_SIZE),hash_str_md5, MD5_BLO
0x3B45                     redraw_window();  
0x3B4A                 break;  
0x3B4F                   case BTN_SHA1:  
0x3B5D                     print_pending_calc(hash_str_sha1);  
0x3B6B                     sprint_hash(check_sum(SHA1_BLOCK_SIZE),hash_str_sha1, SHA1_
0x3B8E                     redraw_window();  
0x3B93                 break;  
0x3B98                   case BTN_SHA256:  
0x3BA6                     print_pending_calc(hash_str_sha256);  
0x3BB4                     sprint_hash(check_sum(SHA256_BLOCK_SIZE),hash_str_sha256, S
0x3BD7                     redraw_window();  
0x3BDC                 break;  
0x3BE1                   case BTN_COPY_MD5:  
0x3BEF                     redraw_window();  
0x3BF4                     copy_to_clipboard(hash_str_md5);  
0x3C02                 break;  
0x3C07                   case BTN_COPY_SHA1:  
0x3C15                     redraw_window();  
0x3C1A                     copy_to_clipboard(hash_str_sha1);  
0x3C28                 break;  
0x3C2D                   case BTN_COPY_SHA256:  
0x3C3B                     redraw_window();  
0x3C40                     copy_to_clipboard(hash_str_sha256);  
0x3C4E                 break;  
0x3C53                   case BTN_PASTE:  
0x3C61                    /* paste_to_edit_buffer();                      redraw_windo
0x3C66                                   case BTN_CMP:  
0x3C74                 if(hash_compare())  
0x3C82                 {  
0x3C82                     edit_box_text_color=GREEN; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç
0x3C92                 }                  else                  {  
0x3C92                     edit_box_text_color=RED; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ
0x3C9D                 }                  redraw_window();  
0x3CA2                 break;  
0x3CA7                   case BTN_QUIT:  
0x3CB5                     exit(0);  
0x3CC3                 break;  
0x2393 
0x23AC 
0x23C5 
0x3D71 
0x3D93 
0x242C 
0x245C 
0x246E 
0x2496 
0x24A0 
0x3E53 
0x3E5D 
0x24B3 
0x24BD 
